import {
  require_react
} from "./chunk-LXGCQ6UQ.js";
import {
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/@kinde-oss/kinde-auth-react/dist/kinde-auth-react.esm.js
var import_react = __toESM(require_react());

// node_modules/@kinde-oss/kinde-auth-pkce-js/dist/kinde-auth-pkce-js.esm.js
var version = "4.0.0";
var SESSION_PREFIX = "pkce-code-verifier";
var flagDataTypeMap;
(function(flagDataTypeMap2) {
  flagDataTypeMap2["s"] = "string";
  flagDataTypeMap2["i"] = "integer";
  flagDataTypeMap2["b"] = "boolean";
})(flagDataTypeMap || (flagDataTypeMap = {}));
var storageMap;
(function(storageMap2) {
  storageMap2["token_bundle"] = "kinde_token";
  storageMap2["access_token"] = "kinde_access_token";
  storageMap2["id_token"] = "kinde_id_token";
  storageMap2["user"] = "user";
  storageMap2["refresh_token"] = "kinde_refresh_token";
})(storageMap || (storageMap = {}));
var InvalidTokenError = class extends Error {
};
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).replace(/(.)/g, (m, p2) => {
    let code = p2.charCodeAt(0).toString(16).toUpperCase();
    if (code.length < 2) {
      code = "0" + code;
    }
    return "%" + code;
  }));
}
function base64UrlDecode(str) {
  let output = str.replace(/-/g, "+").replace(/_/g, "/");
  switch (output.length % 4) {
    case 0:
      break;
    case 2:
      output += "==";
      break;
    case 3:
      output += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return b64DecodeUnicode(output);
  } catch (err) {
    return atob(output);
  }
}
function jwtDecode(token, options) {
  if (typeof token !== "string") {
    throw new InvalidTokenError("Invalid token specified: must be a string");
  }
  options || (options = {});
  const pos = options.header === true ? 0 : 1;
  const part = token.split(".")[pos];
  if (typeof part !== "string") {
    throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);
  }
  let decoded;
  try {
    decoded = base64UrlDecode(part);
  } catch (e2) {
    throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e2.message})`);
  }
  try {
    return JSON.parse(decoded);
  } catch (e2) {
    throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e2.message})`);
  }
}
function base64UrlEncode(str) {
  const numberArray = Array.from(new Uint8Array(str));
  return btoa(String.fromCharCode.apply(null, numberArray)).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function sha256(plain) {
  const encoder = new TextEncoder();
  const data = encoder.encode(plain);
  return window.crypto.subtle.digest("SHA-256", data);
}
async function pkceChallengeFromVerifier(v2) {
  const hashed = await sha256(v2);
  return base64UrlEncode(hashed);
}
function randomString() {
  const array = new Uint32Array(28);
  window.crypto.getRandomValues(array);
  return Array.from(array, (dec) => ("0" + dec.toString(16)).substr(-2)).join("");
}
var LEEWAY = 60;
var isJWTActive = (jwtToken) => {
  const unixTime = Math.floor(Date.now() / 1e3);
  return jwtToken.exp + LEEWAY > unixTime;
};
var setupChallenge = async (authorizationEndpoint, appState) => {
  const state = randomString();
  const code_verifier = randomString();
  const code_challenge = await pkceChallengeFromVerifier(code_verifier);
  sessionStorage.setItem(`${SESSION_PREFIX}-${state}`, JSON.stringify({
    codeVerifier: code_verifier,
    appState
  }));
  const url = new URL(authorizationEndpoint);
  return { state, code_challenge, url };
};
var createStore = () => {
  let items = {};
  const getItem = (key) => {
    return items[key];
  };
  const setItem = (key, value) => {
    items[key] = value;
  };
  const removeItem = (key) => {
    delete items[key];
  };
  const reset = () => {
    items = {};
  };
  return {
    reset,
    getItem,
    removeItem,
    setItem
  };
};
var store = createStore();
var getClaim = (claim, tokenKey = "access_token") => {
  const token = store.getItem(`kinde_${tokenKey}`);
  return token ? { name: claim, value: token[claim] } : null;
};
var getClaimValue = (claim, tokenKey = "access_token") => {
  const obj = getClaim(claim, tokenKey);
  return obj && obj.value;
};
var getFlag = (code, defaultValue, flagType) => {
  const flags = getClaimValue("feature_flags");
  const flag = flags && flags[code] ? flags[code] : {};
  if (flag.v == null && defaultValue == null) {
    throw Error(`Flag ${code} was not found, and no default value has been provided`);
  }
  if (flagType && flag.t && flagType !== flag.t) {
    throw Error(`Flag ${code} is of type ${flagDataTypeMap[flag.t]} - requested type ${flagDataTypeMap[flagType]}`);
  }
  return {
    code,
    type: flagDataTypeMap[flag.t || flagType],
    value: flag.v == null ? defaultValue : flag.v,
    is_default: flag.v == null
  };
};
var getBooleanFlag = (code, defaultValue) => {
  try {
    const flag = getFlag(code, defaultValue, "b");
    return flag.value;
  } catch (err) {
    console.error(err);
    return err;
  }
};
var getIntegerFlag = (code, defaultValue) => {
  try {
    const flag = getFlag(code, defaultValue, "i");
    return flag.value;
  } catch (err) {
    console.error(err);
    return err;
  }
};
var getStringFlag = (code, defaultValue) => {
  try {
    const flag = getFlag(code, defaultValue, "s");
    return flag.value;
  } catch (err) {
    console.error(err);
    return err;
  }
};
var getUserOrganizations = () => {
  const orgCodes = getClaimValue("org_codes", "id_token") ?? [];
  return {
    orgCodes
  };
};
var PAYLOAD_CLAIMS = ["iss", "azp"];
var isTokenValid = (token, config) => {
  if (!token) {
    throw new Error("ID token is required");
  }
  PAYLOAD_CLAIMS.forEach((claim) => {
    if (!token.payload[claim]) {
      throw new Error(`(${claim}) claim is required.`);
    }
    if (token.payload[claim] !== config[claim]) {
      throw new Error(`${claim} claim mismatch. Expected: "${config[claim]}", Received: "${token.payload[claim]}"`);
    }
  });
  if (token.header.alg !== "RS256") {
    throw new Error(`Unsupported signature alg. Expected: "RS256", Received: "${token.header.alg}"`);
  }
  if (config.aud) {
    if (!Array.isArray(token.payload.aud)) {
      throw new Error("(aud) claim must be an array");
    }
    if (!token.payload.aud.every((element) => config.aud.includes(element))) {
      throw new Error(`(aud) claim mismatch. Expected: "${config.aud}", Received: "${token.payload.aud.join(", ")}"`);
    }
  }
  const isJWTExpired = !isJWTActive(token.payload);
  if (isJWTExpired) {
    throw new Error(`Token expired`);
  }
  return true;
};
var isCustomDomain = (url) => {
  const domain = new URL(url);
  const bareDomain = domain.hostname.split(".").slice(-2).join(".");
  return bareDomain !== "kinde.com";
};
var createKindeClient = async (options) => {
  if (!options) {
    throw Error("Please provide your Kinde credentials");
  }
  if (options !== Object(options)) {
    throw Error("The Kinde SDK must be initiated with an object");
  }
  const { audience, client_id: clientId, domain, is_dangerously_use_local_storage = false, redirect_uri, logout_uri = redirect_uri, on_redirect_callback, on_error_callback, scope = "openid profile email offline", proxy_redirect_uri, _framework, _frameworkVersion } = options;
  if (audience && typeof audience !== "string") {
    throw Error("Please supply a valid audience for your api");
  }
  if (scope && typeof scope !== "string") {
    throw Error("Please supply a valid scope");
  }
  if (!redirect_uri || typeof options.redirect_uri !== "string") {
    throw Error("Please supply a valid redirect_uri for your users to be redirected after successful authentication");
  }
  if (!domain || typeof domain !== "string") {
    throw Error("Please supply a valid Kinde domain so we can connect to your account");
  }
  if (typeof is_dangerously_use_local_storage !== "boolean") {
    throw TypeError("Please supply a boolean value for is_dangerously_use_local_storage");
  }
  const client_id = clientId || "spa@live";
  const isDevelopment = location.hostname === "localhost" || location.hostname === "127.0.0.1";
  const isUseCookie = !isDevelopment && !is_dangerously_use_local_storage && isCustomDomain(domain);
  const isUseLocalStorage = isDevelopment || is_dangerously_use_local_storage;
  const config = {
    audience,
    client_id,
    redirect_uri,
    authorization_endpoint: `${domain}/oauth2/auth`,
    token_endpoint: `${domain}/oauth2/token`,
    requested_scopes: scope,
    domain,
    _framework,
    _frameworkVersion
  };
  const setStore = (data) => {
    if (!data || data.error)
      return;
    const idToken = jwtDecode(data.id_token);
    const idTokenHeader = jwtDecode(data.id_token, { header: true });
    const accessToken = jwtDecode(data.access_token);
    const accessTokenHeader = jwtDecode(data.access_token, { header: true });
    const validatorOptions = {
      iss: domain,
      azp: clientId,
      aud: audience
    };
    isTokenValid({
      payload: idToken,
      header: idTokenHeader
    }, { ...validatorOptions, aud: clientId });
    isTokenValid({
      payload: accessToken,
      header: accessTokenHeader
    }, validatorOptions);
    {
      store.setItem(storageMap.token_bundle, data);
      store.setItem(storageMap.access_token, accessToken);
      store.setItem(storageMap.id_token, idToken);
      store.setItem(storageMap.user, {
        id: idToken.sub,
        given_name: idToken.given_name,
        family_name: idToken.family_name,
        email: idToken.email,
        picture: idToken.picture
      });
      if (isUseLocalStorage) {
        localStorage.setItem(storageMap.refresh_token, data.refresh_token);
      } else {
        store.setItem(storageMap.refresh_token, data.refresh_token);
      }
    }
  };
  const useRefreshToken = async ({ tokenType } = { tokenType: storageMap.access_token }) => {
    const refresh_token = isUseLocalStorage ? localStorage.getItem(storageMap.refresh_token) : store.getItem(storageMap.refresh_token);
    if (refresh_token || isUseCookie) {
      try {
        const response = await fetch(config.token_endpoint, {
          method: "POST",
          ...isUseCookie && { credentials: "include" },
          headers: new Headers({
            "Content-type": "application/x-www-form-urlencoded; charset=UTF-8",
            "Kinde-SDK": `
            ${config._framework || "JavaScript"}/${config._frameworkVersion || version}`
          }),
          body: new URLSearchParams({
            client_id: config.client_id,
            grant_type: "refresh_token",
            ...!isUseCookie && refresh_token && { refresh_token }
          })
        });
        const data = await response.json();
        setStore(data);
        if (tokenType === storageMap.id_token) {
          return data.id_token;
        }
        return data.access_token;
      } catch (err) {
        console.error(err);
      }
    }
  };
  const getTokenType = async (tokenType, options2) => {
    const token = store.getItem(storageMap.token_bundle);
    if (!token || options2.isForceRefresh) {
      return await useRefreshToken({ tokenType });
    }
    const tokenToReturn = store.getItem(tokenType);
    const isTokenActive = isJWTActive(tokenToReturn);
    if (isTokenActive) {
      return tokenType === storageMap.access_token ? token.access_token : token.id_token;
    } else {
      return await useRefreshToken({ tokenType });
    }
  };
  const getToken = async (options2 = {}) => {
    return await getTokenType(storageMap.access_token, options2);
  };
  const getIdToken = async (options2 = {}) => {
    return await getTokenType(storageMap.id_token, options2);
  };
  const isAuthenticated = async () => {
    const accessToken = store.getItem(storageMap.access_token);
    if (!accessToken) {
      return false;
    }
    const isTokenActive = isJWTActive(accessToken);
    if (isTokenActive) {
      return true;
    }
    await useRefreshToken();
    return true;
  };
  const getPermissions = () => {
    const orgCode = getClaimValue("org_code");
    const permissions = getClaimValue("permissions") ?? [];
    return {
      permissions,
      orgCode
    };
  };
  const getPermission = (key) => {
    const orgCode = getClaimValue("org_code");
    const permissions = getClaimValue("permissions") ?? [];
    return {
      isGranted: permissions.some((p2) => p2 === key),
      orgCode
    };
  };
  const getOrganization = () => {
    const orgCode = getClaimValue("org_code");
    return {
      orgCode
    };
  };
  const clearUrlParams = () => {
    const url = new URL(window.location.toString());
    url.search = "";
    window.history.pushState({}, "", url);
  };
  const handleRedirectToApp = async (q) => {
    const code = q.get("code");
    const state = q.get("state");
    const error = q.get("error");
    const stringState = sessionStorage.getItem(`${SESSION_PREFIX}-${state}`);
    if (!stringState) {
      console.error("Invalid state");
    } else {
      if (error) {
        const error2 = q.get("error");
        const errorDescription = q.get("error_description");
        clearUrlParams();
        sessionStorage.removeItem(`${SESSION_PREFIX}-${state}`);
        const { appState: appState2 } = JSON.parse(stringState);
        if (on_error_callback) {
          on_error_callback({
            error: error2,
            errorDescription,
            state,
            appState: appState2
          });
        } else {
          window.location.href = appState2.kindeOriginUrl;
        }
        return false;
      }
      const { appState, codeVerifier } = JSON.parse(stringState);
      try {
        const response = await fetch(config.token_endpoint, {
          method: "POST",
          ...isUseCookie && { credentials: "include" },
          headers: new Headers({
            "Content-type": "application/x-www-form-urlencoded; charset=UTF-8",
            "Kinde-SDK": `${config._framework || "JavaScript"}/${config._frameworkVersion || version}`
          }),
          body: new URLSearchParams({
            client_id: config.client_id,
            code,
            code_verifier: codeVerifier,
            grant_type: "authorization_code",
            redirect_uri: config.redirect_uri
          })
        });
        const data = await response.json();
        setStore(data);
        clearUrlParams();
        sessionStorage.removeItem(`${SESSION_PREFIX}-${state}`);
        const user = getUser();
        if (on_redirect_callback) {
          on_redirect_callback(user, appState);
        }
      } catch (err) {
        console.error(err);
        sessionStorage.removeItem(`${SESSION_PREFIX}-${state}`);
      }
    }
  };
  const redirectToKinde = async (options2) => {
    const { app_state = {}, prompt, is_create_org, org_name = "", org_code, authUrlParams = {} } = options2;
    if (!app_state.kindeOriginUrl) {
      app_state.kindeOriginUrl = window.location.href;
    }
    const { state, code_challenge, url } = await setupChallenge(config.authorization_endpoint, app_state);
    const searchParams = {
      redirect_uri,
      client_id,
      response_type: "code",
      scope: config.requested_scopes,
      code_challenge,
      code_challenge_method: "S256",
      state
    };
    if (prompt) {
      searchParams.prompt = prompt;
    }
    if (org_code) {
      searchParams.org_code = org_code;
    }
    if (is_create_org) {
      searchParams.is_create_org = String(is_create_org);
      searchParams.org_name = org_name;
    }
    const urlSearchParams = new URLSearchParams(Object.assign(authUrlParams, searchParams));
    if (audience) {
      audience.trim().split(/\s+/).forEach((aud) => {
        urlSearchParams.append("audience", aud);
      });
    }
    url.search = String(urlSearchParams);
    window.location.href = url.toString();
  };
  const register = async (options2) => {
    await redirectToKinde({
      ...options2,
      prompt: "create"
    });
  };
  const login = async (options2) => {
    await redirectToKinde({
      ...options2
    });
  };
  const createOrg = async (options2) => {
    await redirectToKinde({
      ...options2,
      prompt: "create",
      is_create_org: true
    });
  };
  const getUser = () => {
    return store.getItem(storageMap.user);
  };
  const getUserProfile = async () => {
    const token = await getToken();
    const headers = {
      Accept: "application/json",
      Authorization: `Bearer ${token}`
    };
    try {
      const res = await fetch(`${config.domain}/oauth2/v2/user_profile`, {
        method: "GET",
        headers
      });
      const json = await res.json();
      store.setItem(storageMap.user, {
        id: json.sub,
        given_name: json.given_name,
        family_name: json.family_name,
        email: json.email,
        picture: json.picture
      });
      return store.getItem(storageMap.user);
    } catch (err) {
      console.error(err);
    }
  };
  const logout = async () => {
    const url = new URL(`${config.domain}/logout`);
    try {
      store.reset();
      if (isUseLocalStorage) {
        localStorage.removeItem(storageMap.refresh_token);
      }
      const searchParams = new URLSearchParams({
        redirect: logout_uri
      });
      url.search = String(searchParams);
      window.location.href = url.toString();
    } catch (err) {
      console.error(err);
    }
  };
  const init = async () => {
    const q = new URLSearchParams(window.location.search);
    if (isKindeRedirect(q)) {
      await handleRedirectToApp(q);
    } else {
      if (isUseCookie || isUseLocalStorage) {
        await useRefreshToken();
      }
    }
  };
  const isKindeRedirect = (searchParams) => {
    const hasOauthCode = searchParams.has("code");
    const hasError = searchParams.has("error");
    if (!hasOauthCode && !hasError)
      return false;
    const { protocol, host, pathname } = window.location;
    const currentRedirectUri = proxy_redirect_uri || `${protocol}//${host}${pathname}`;
    return currentRedirectUri === redirect_uri || currentRedirectUri === `${redirect_uri}/`;
  };
  await init();
  return {
    getToken,
    getIdToken,
    getUser,
    getUserProfile,
    login,
    logout,
    register,
    isAuthenticated,
    createOrg,
    getClaim,
    getFlag,
    getBooleanFlag,
    getStringFlag,
    getIntegerFlag,
    getPermissions,
    getPermission,
    getOrganization,
    getUserOrganizations
  };
};

// node_modules/@kinde-oss/kinde-auth-react/dist/kinde-auth-react.esm.js
var s = function() {
  return s = Object.assign || function(e2) {
    for (var r2, n2 = 1, t2 = arguments.length; n2 < t2; n2++)
      for (var o2 in r2 = arguments[n2])
        Object.prototype.hasOwnProperty.call(r2, o2) && (e2[o2] = r2[o2]);
    return e2;
  }, s.apply(this, arguments);
};
function l(e2, r2, n2, t2) {
  return new (n2 || (n2 = Promise))(function(o2, i2) {
    function u2(e3) {
      try {
        c(t2.next(e3));
      } catch (e4) {
        i2(e4);
      }
    }
    function a2(e3) {
      try {
        c(t2.throw(e3));
      } catch (e4) {
        i2(e4);
      }
    }
    function c(e3) {
      var r3;
      e3.done ? o2(e3.value) : (r3 = e3.value, r3 instanceof n2 ? r3 : new n2(function(e4) {
        e4(r3);
      })).then(u2, a2);
    }
    c((t2 = t2.apply(e2, r2 || [])).next());
  });
}
function f(e2, r2) {
  var n2, t2, o2, i2, u2 = { label: 0, sent: function() {
    if (1 & o2[0])
      throw o2[1];
    return o2[1];
  }, trys: [], ops: [] };
  return i2 = { next: a2(0), throw: a2(1), return: a2(2) }, "function" == typeof Symbol && (i2[Symbol.iterator] = function() {
    return this;
  }), i2;
  function a2(a3) {
    return function(c) {
      return function(a4) {
        if (n2)
          throw new TypeError("Generator is already executing.");
        for (; i2 && (i2 = 0, a4[0] && (u2 = 0)), u2; )
          try {
            if (n2 = 1, t2 && (o2 = 2 & a4[0] ? t2.return : a4[0] ? t2.throw || ((o2 = t2.return) && o2.call(t2), 0) : t2.next) && !(o2 = o2.call(t2, a4[1])).done)
              return o2;
            switch (t2 = 0, o2 && (a4 = [2 & a4[0], o2.value]), a4[0]) {
              case 0:
              case 1:
                o2 = a4;
                break;
              case 4:
                return u2.label++, { value: a4[1], done: false };
              case 5:
                u2.label++, t2 = a4[1], a4 = [0];
                continue;
              case 7:
                a4 = u2.ops.pop(), u2.trys.pop();
                continue;
              default:
                if (!(o2 = u2.trys, (o2 = o2.length > 0 && o2[o2.length - 1]) || 6 !== a4[0] && 2 !== a4[0])) {
                  u2 = 0;
                  continue;
                }
                if (3 === a4[0] && (!o2 || a4[1] > o2[0] && a4[1] < o2[3])) {
                  u2.label = a4[1];
                  break;
                }
                if (6 === a4[0] && u2.label < o2[1]) {
                  u2.label = o2[1], o2 = a4;
                  break;
                }
                if (o2 && u2.label < o2[2]) {
                  u2.label = o2[2], u2.ops.push(a4);
                  break;
                }
                o2[2] && u2.ops.pop(), u2.trys.pop();
                continue;
            }
            a4 = r2.call(e2, u2);
          } catch (e3) {
            a4 = [6, e3], t2 = 0;
          } finally {
            n2 = o2 = 0;
          }
        if (5 & a4[0])
          throw a4[1];
        return { value: a4[0] ? a4[1] : void 0, done: true };
      }([a3, c]);
    };
  }
}
var g = { isAuthenticated: false, isLoading: true };
var d = (0, import_react.createContext)(s({}, g));
var h = function() {
  var e2 = (0, import_react.useContext)(d);
  if (void 0 === e2)
    throw new Error("Oooops! useKindeAuth must be used within a KindeProvider");
  return e2;
};
var v = { INITIALISED: function(e2, r2) {
  return s(s({}, e2), { isAuthenticated: Boolean(r2.user), user: r2.user, isLoading: false, error: void 0 });
}, LOGOUT: function(e2) {
  return s(s({}, e2), { isAuthenticated: false, user: void 0 });
}, ERROR: function(e2, r2) {
  return s(s({}, e2), { isLoading: false, error: r2.error });
} };
var p = function(e2, r2) {
  return v[r2.type] ? v[r2.type](e2, r2) : e2;
};
var y = function() {
  window.history.replaceState({}, document.title, window.location.pathname);
};
var w = function(r2) {
  var n2 = r2.audience, h2 = r2.scope, v2 = r2.clientId, w2 = r2.children, b = r2.domain, m = r2.isDangerouslyUseLocalStorage, k = void 0 !== m && m, O = r2.redirectUri, I = r2.onRedirectCallback, _ = void 0 === I ? y : I, U = r2.onErrorCallback, E = r2.logoutUri, F = (0, import_react.useState)(), P = F[0], R = F[1], S = (0, import_react.useReducer)(p, g), T = S[0], L = S[1];
  (0, import_react.useEffect)(function() {
    try {
      l(void 0, void 0, void 0, function() {
        var e2;
        return f(this, function(r3) {
          switch (r3.label) {
            case 0:
              return [4, createKindeClient({ audience: n2, scope: h2, client_id: v2, domain: b, is_dangerously_use_local_storage: k, redirect_uri: O, logout_uri: E, on_redirect_callback: _, on_error_callback: U, _framework: "React", _frameworkVersion: "4.0.1" })];
            case 1:
              return e2 = r3.sent(), R(e2), [2];
          }
        });
      });
    } catch (e2) {
      console.error(e2);
    }
    return function() {
    };
  }, [n2, h2, v2, b, k, O, E]), (0, import_react.useEffect)(function() {
    var e2 = true;
    return function() {
      if (P && e2)
        try {
          var r3 = P.getUser();
          L({ type: "INITIALISED", user: r3 });
        } catch (e3) {
          console.log(e3), L({ type: "ERROR", error: "login error" });
        }
    }(), function() {
      e2 = false;
    };
  }, [P]);
  var x = (0, import_react.useCallback)(function(e2) {
    return P.login(e2);
  }, [P]), A = (0, import_react.useCallback)(function(e2) {
    return P.register(e2);
  }, [P]), z = (0, import_react.useCallback)(function() {
    return P.logout();
  }, [P]), C = (0, import_react.useCallback)(function(e2, r3) {
    return P.getClaim(e2, r3);
  }, [P]), j = (0, import_react.useCallback)(function(e2, r3, n3) {
    return P.getFlag(e2, r3, n3);
  }, [P]), B = (0, import_react.useCallback)(function(e2, r3) {
    return P.getBooleanFlag(e2, r3);
  }, [P]), D = (0, import_react.useCallback)(function(e2, r3) {
    return P.getIntegerFlag(e2, r3);
  }, [P]), G = (0, import_react.useCallback)(function(e2, r3) {
    return P.getStringFlag(e2, r3);
  }, [P]), K = (0, import_react.useCallback)(function() {
    return P.getPermissions();
  }, [P]), N = (0, import_react.useCallback)(function(e2) {
    return P.getPermission(e2);
  }, [P]), V = (0, import_react.useCallback)(function() {
    return P.getOrganization();
  }, [P]), q = (0, import_react.useCallback)(function() {
    return P.getUserOrganizations();
  }, [P]), H = (0, import_react.useCallback)(function(e2) {
    return P.createOrg(e2);
  }, [P]), J = (0, import_react.useCallback)(function(e2) {
    return l(void 0, void 0, void 0, function() {
      var r3, n3;
      return f(this, function(t2) {
        switch (t2.label) {
          case 0:
            return t2.trys.push([0, 2, , 3]), [4, P.getToken(e2)];
          case 1:
            return r3 = t2.sent(), [3, 3];
          case 2:
            throw n3 = t2.sent(), console.error(n3);
          case 3:
            return [2, r3];
        }
      });
    });
  }, [P]), M = (0, import_react.useCallback)(function(e2) {
    return l(void 0, void 0, void 0, function() {
      var r3, n3;
      return f(this, function(t2) {
        switch (t2.label) {
          case 0:
            return t2.trys.push([0, 2, , 3]), [4, P.getIdToken(e2)];
          case 1:
            return r3 = t2.sent(), [3, 3];
          case 2:
            throw n3 = t2.sent(), console.error(n3);
          case 3:
            return [2, r3];
        }
      });
    });
  }, [P]), Q = (0, import_react.useCallback)(function() {
    return P.getUser();
  }, [P]), W = (0, import_react.useMemo)(function() {
    return s(s({}, T), { getToken: J, getIdToken: M, login: x, register: A, logout: z, createOrg: H, getBooleanFlag: B, getClaim: C, getFlag: j, getIntegerFlag: D, getPermissions: K, getPermission: N, getOrganization: V, getStringFlag: G, getUserOrganizations: q, getUser: Q });
  }, [T, J, M, x, A, z, H, C, K, N, V, q, Q]);
  return import_react.default.createElement(d.Provider, { value: W }, w2);
};
export {
  w as KindeProvider,
  h as useKindeAuth
};
//# sourceMappingURL=@kinde-oss_kinde-auth-react.js.map
